# Copyright (c) 2021, Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ .Values.api.impersonatorRoleName }}
rules:
- apiGroups: [""]
  resources: ["users", "groups"]
  verbs: ["impersonate"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ .Values.api.impersonatorRoleName }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ .Values.api.impersonatorRoleName }}
subjects:
- kind: ServiceAccount
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-nginx-conf
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Values.api.name }}
data:
  conf.lua: |
    local function logJsonMessage(logLevel, msg, err)
      local cjson = require "cjson"
      local logMsg = ""
      if error then
        logMsg = cjson.encode({message = msg, error = err})
      else
        logMsg = cjson.encode({message = msg})
      end
      ngx.log(logLevel, logMsg)
    end

    local function read_file(path)
      local file = io.open(path)
      if not file then return nil end
      local content = file:read "*a"
      file:close()
      return content
    end

    ngx.header["Access-Control-Allow-Headers"] = "authorization"

    if ngx.req.get_method() == "OPTIONS" then
      ngx.status = 200
      ngx.exit(ngx.HTTP_OK)
    end

    logJsonMessage(ngx.INFO, "Extracting authorization header from request.")
    local h, err = ngx.req.get_headers()["authorization"]
    if err then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Error while reading authorization header from request.", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    if not (h) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid authorization header", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Extract jwt token from authorization header.")
    local token = string.sub(h, 8)
    if not (token) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid bearer token in authorization header")
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    local keycloakUrl = read_file("/api-config/keycloak-url");
    if not (keycloakUrl) then
      keycloakUrl = "http://keycloak-http.keycloak.svc.cluster.local"
      logJsonMessage(ngx.INFO, "No keycloak-url specified in api-config.Using in-cluster keycloak url.")
    end

    logJsonMessage(ngx.INFO, "Read public key from keycloak.")
    local http = require "resty.http"
    local httpc = http.new()
    local res, err = httpc:request_uri(keycloakUrl .. "/auth/realms/verrazzano-system")
    if err then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Error accessing keycloak", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    local cjson = require "cjson"
    local data = cjson.decode(res.body)
    if not (data.public_key) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "No public_key retreived from keycloak")
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Validate JWT token.")
    local key = "-----BEGIN PUBLIC KEY-----\n" .. data.public_key .. "\n-----END PUBLIC KEY-----"
    local jwt = require "resty.jwt"
    local jwt_obj = jwt:load_jwt(token)
    local verified = jwt:verify_jwt_obj(key, jwt_obj)
    if (tostring(jwt_obj.valid) == "false" or tostring(jwt_obj.verified) == "false") then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid JWT token", jwt_obj.reason)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end


    logJsonMessage(ngx.INFO, "Read service account token.")
    local serviceAccountToken = read_file("/run/secrets/kubernetes.io/serviceaccount/token");
    if not (serviceAccountToken) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "No service account token presnet in pod.")
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Set headers")
    ngx.req.set_header("Authorization", "Bearer " .. serviceAccountToken)
    if ( jwt_obj.payload and jwt_obj.payload.groups) then
      logJsonMessage(ngx.INFO, ("Adding groups " .. cjson.encode(jwt_obj.payload.groups)))
      ngx.req.set_header("Impersonate-Group", jwt_obj.payload.groups)
    end
    if ( jwt_obj.payload and jwt_obj.payload.sub) then
      logJsonMessage(ngx.INFO, ("Adding sub " .. jwt_obj.payload.sub))
      ngx.req.set_header("Impersonate-User", jwt_obj.payload.sub)
    end
  nginx.conf: |
    #user  nobody;
    worker_processes  1;

    #error_log  logs/error.log;
    #error_log  logs/error.log  notice;
    #error_log  logs/error.log  info;

    pid        logs/nginx.pid;


    events {
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;

        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';

        error_log  logs/error.log  info;

        sendfile        on;
        #tcp_nopush     on;

        #keepalive_timeout  0;
        keepalive_timeout  65;

        #gzip  on;
        #
        lua_package_path '/usr/local/share/lua/5.1/?.lua;;';
        lua_package_cpath '/usr/local/lib/lua/5.1/?.so;;';
        resolver _NAMESERVER_;
        # cache for discovery metadata documents
        lua_shared_dict discovery 1m;
        #  cache for JWKs
        lua_shared_dict jwks 1m;
        lua_ssl_verify_depth 2;
        lua_ssl_trusted_certificate /etc/nginx/ca-bundle;

        server {
            listen       8775;
            server_name  apiserver;
            root     /opt/nginx/html;
            rewrite_by_lua_file /etc/nginx/conf.lua;
            #charset koi8-r;

            #access_log  logs/host.access.log  main;
            expires           0;
            add_header        Cache-Control private;

            location / {
              proxy_pass https://kubernetes.default.svc/;
            }

            error_page 404 /404.html;
              location = /40x.html {
            }

            #error_page  404              /404.html;

            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;

            location = /50x.html {
                root   html;
            }

            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ {
            #    proxy_pass   http://127.0.0.1;
            #}

            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
            #location ~ \.php$ {
            #    root           html;
            #    fastcgi_pass   127.0.0.1:9000;
            #    fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    include        fastcgi_params;
            #}

            # deny access to .htaccess files, if Apache's document root
            # concurs with nginx's one
            #
            #location ~ /\.ht {
            #    deny  all;
            #}
        }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    }
  startup.sh: |
    #!/bin/bash
    cd `dirname $0`
    cp `dirname $0`/nginx.conf /etc/nginx/nginx.conf
    cp `dirname $0`/conf.lua /etc/nginx/conf.lua
    nameserver=$(grep -i nameserver /etc/resolv.conf | awk '{split($0,line," "); print line[2]}')
    sed -i -e "s|_NAMESERVER_|${nameserver}|g" /etc/nginx/nginx.conf

    mkdir -p /etc/nginx/logs
    touch /etc/nginx/logs/error.log

    export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
    ln -s /etc/ssl/certs/ca-bundle.trust.crt /etc/nginx/ca-bundle

    /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf -t -p /etc/nginx
    /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf -p /etc/nginx

    sh -c "`dirname $0`/reload.sh &"
    tail -f /etc/nginx/logs/error.log
  reload.sh: |
    #!/bin/bash

    function reload() {
      nginx -t -p /etc/nginx
      if [ $? -eq 0 ]
      then
        echo "Detected Nginx Configuration Change"
        echo "Executing: nginx -s reload -p /etc/nginx"
        nginx -s reload -p /etc/nginx
      fi
    }

    while true
    do
    if [[ -L /etc/nginx/ca-bundle ]] &&  [[ -f /api-config/admin-ca-bundle ]] &&  [[ -s /api-config/admin-ca-bundle ]] && [[ "`realpath /etc/nginx/ca-bundle`" != "/api-config/admin-ca-bundle" ]]; then
      rm -rf /etc/nginx/ca-bundle
      ln -s /api-config/admin-ca-bundle /etc/nginx/ca-bundle
      reload
    fi
    if [[ -L /etc/nginx/ca-bundle ]] &&  [[ ! -f /api-config/admin-ca-bundle ]] && [[ "`realpath /etc/nginx/ca-bundle`" == "/api-config/admin-ca-bundle" ]] && [[ -f /api-config/default-ca-bundle ]]  && [[ -s /api-config/default-ca-bundle ]]; then
      rm -rf /etc/nginx/ca-bundle
      ln -s /api-config/default-ca-bundle /etc/nginx/ca-bundle
      reload
    fi
    if [[ ! -L /etc/nginx/ca-bundle ]] &&  [[ -f /api-config/admin-ca-bundle ]]  &&  [[ -s /api-config/admin-ca-bundle ]]; then
      ln -s /api-config/admin-ca-bundle /etc/nginx/ca-bundle
      reload
    fi
    if [[ ! -L /etc/nginx/ca-bundle ]] &&  [[ -f /api-config/default-ca-bundle ]]  &&  [[ -s /api-config/default-ca-bundle ]]; then
      ln -s /api-config/default-ca-bundle /etc/nginx/ca-bundle
      reload
    fi
    sleep 5 
    done
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: {{ .Values.api.name }}
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: {{ .Values.api.name }}
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "true"
      labels:
        app: {{ .Values.api.name }}
    spec:
      volumes:
       - name: api-config
         projected:
           sources:
            - secret:
                name: system-tls
                items:
                  - key: ca.crt
                    path: default-ca-bundle
            - secret:
                name: verrazzano-cluster-registration
                optional: true
                items:
                  - key: ca-bundle
                    path: admin-ca-bundle
                  - key: keycloak-url
                    path: keycloak-url
            - configMap:
                name: api-nginx-conf
                items:
                  - key: startup.sh
                    path: startup.sh
                    mode: 0755
                  - key: nginx.conf
                    path: nginx.conf
                    mode: 0744 
                  - key: conf.lua
                    path: conf.lua
                    mode: 0755
                  - key: reload.sh
                    path: reload.sh
                    mode: 0755
      containers:
      - image: {{ .Values.api.imageName }}:{{ .Values.api.imageVersion }}
        imagePullPolicy: {{ .Values.api.pullPolicy }}
        name: {{ .Values.api.name }}
        command: ["/api-config/startup.sh"]
        ports:
            - containerPort: {{ .Values.api.port }}
        volumeMounts:
        - mountPath: /api-config
          name: api-config
      serviceAccount: {{ .Values.api.name }}
---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
spec:
  ports:
  - name: api
    port: {{ .Values.api.port }}
    protocol: TCP
    targetPort: {{ .Values.api.port }}
  selector:
    app: {{ .Values.api.name }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
{{- if .Values.global.imagePullSecrets }}
imagePullSecrets:
{{- range .Values.global.imagePullSecrets }}
- name: {{ . }}
{{- end }}
{{- end }}
