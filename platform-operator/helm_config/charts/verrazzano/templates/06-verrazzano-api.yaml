# Copyright (c) 2021, Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ .Values.api.impersonatorRoleName }}
rules:
- apiGroups: [""]
  resources: ["users", "groups"]
  verbs: ["impersonate"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ .Values.api.impersonatorRoleName }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ .Values.api.impersonatorRoleName }}
subjects:
- kind: ServiceAccount
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-nginx-conf
  namespace: {{ .Release.Namespace }}
  labels:
    app: {{ .Values.api.name }}
data:
  conf.lua: |
    vzApiHost = os.getenv("VZ_API_HOST")
    vzApiVersion = os.getenv("VZ_API_VERSION")
    local function logJsonMessage(logLevel, msg, err)
      local cjson = require "cjson"
      local logMsg = ""
      if error then
        logMsg = cjson.encode({message = msg, error = err})
      else
        logMsg = cjson.encode({message = msg})
      end
      ngx.log(logLevel, logMsg)
    end

    local function read_file(path)
      local file = io.open(path)
      if not file then return nil end
      local content = file:read "*a"
      file:close()
      return content
    end

    local function write_file(path, data)
      local file = io.open(path, "a+")
      if not file then return nil end
      file:write(data)
      file:close()
    end

    local function getServiceAccountToken()
      logJsonMessage(ngx.INFO, "Read service account token.")
      local serviceAccountToken = read_file("/run/secrets/kubernetes.io/serviceaccount/token");
      if not (serviceAccountToken) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "No service account token present in pod.")
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end
      return serviceAccountToken
    end

    local function getLocalServerURL()
      local host = os.getenv("KUBERNETES_SERVICE_HOST")
      local port = os.getenv("KUBERNETES_SERVICE_PORT")
      local serverUrl = "https://" .. host .. ":" .. port
      return serverUrl
    end

    local function split(s, delimiter)
      local result = {};
      for match in (s..delimiter):gmatch("(.-)"..delimiter) do
          table.insert(result, match);
      end
      return result;
    end

    local function contains(table, element)
      for _, value in pairs(table) do
        if value == element then
          return true
        end
      end
      return false
    end

    local function capture(cmd, raw)
      local f = assert(io.popen(cmd, 'r'))
      local s = assert(f:read('*a'))
      f:close()
      if raw then return s end
      s = string.gsub(s, '^%s+', '')
      s = string.gsub(s, '%s+$', '')
      s = string.gsub(s, '[\n\r]+', ' ')
      return s
    end

    local function getK8SResource(resourcePath)
      local http = require "resty.http"
      local httpc = http.new()
      local res, err = httpc:request_uri("https://" .. vzApiHost .. "/" .. vzApiVersion .. resourcePath,{
          headers = {
              ["Authorization"] = ngx.req.get_headers()["authorization"],
          },
      })
      if err then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Error accessing vz api", err)
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end

      if not(res) or not (res.body) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Unable to get k8s resource.")
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end
      local cjson = require "cjson"
      return cjson.decode(res.body)
    end

    local function getVMC(cluster)
      return getK8SResource("/apis/clusters.verrazzano.io/v1alpha1/namespaces/verrazzano-mc/verrazzanomanagedclusters/" .. cluster)
    end

    local function getSecret(secret)
      return getK8SResource("/api/v1/namespaces/verrazzano-mc/secrets/" .. secret)
    end

    if ngx.req.get_method() == "OPTIONS" then
      ngx.status = 200
      ngx.exit(ngx.HTTP_OK)
    end

    logJsonMessage(ngx.INFO, "Extracting authorization header from request.")
    local h, err = ngx.req.get_headers()["authorization"]
    if err then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Error while reading authorization header from request.", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    if not (h) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid authorization header", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Extract jwt token from authorization header.")
    local token = string.sub(h, 8)
    if not (token) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid bearer token in authorization header")
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    local keycloakUrl = read_file("/api-config/keycloak-url");
    if not (keycloakUrl) then
      keycloakUrl = "http://keycloak-http.keycloak.svc.cluster.local"
      logJsonMessage(ngx.INFO, "No keycloak-url specified in api-config.Using in-cluster keycloak url.")
    end

    logJsonMessage(ngx.INFO, "Read public key from keycloak.")
    local http = require "resty.http"
    local httpc = http.new()
    local res, err = httpc:request_uri(keycloakUrl .. "/auth/realms/verrazzano-system")
    if err then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Error accessing keycloak", err)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    local cjson = require "cjson"
    local data = cjson.decode(res.body)
    if not (data.public_key) then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "No public_key retreived from keycloak")
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Validate JWT token.")
    local key = "-----BEGIN PUBLIC KEY-----\n" .. data.public_key .. "\n-----END PUBLIC KEY-----"
    local jwt = require "resty.jwt"
    local jwt_obj = jwt:load_jwt(token)
    local verified = jwt:verify_jwt_obj(key, jwt_obj)
    if (tostring(jwt_obj.valid) == "false" or tostring(jwt_obj.verified) == "false") then
      ngx.status = 401
      logJsonMessage(ngx.ERR, "Invalid JWT token", jwt_obj.reason)
      ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    logJsonMessage(ngx.INFO, "Set groups and users")
    if ( jwt_obj.payload and jwt_obj.payload.groups) then
      logJsonMessage(ngx.INFO, ("Adding groups " .. cjson.encode(jwt_obj.payload.groups)))
      ngx.req.set_header("Impersonate-Group", jwt_obj.payload.groups)
    end
    if ( jwt_obj.payload and jwt_obj.payload.sub) then
      logJsonMessage(ngx.INFO, ("Adding sub " .. jwt_obj.payload.sub))
      ngx.req.set_header("Impersonate-User", jwt_obj.payload.sub)
    end

    local serverUrl = getLocalServerURL()
    local args = ngx.req.get_uri_args()
    if args.cluster then
      logJsonMessage(ngx.INFO, "Read vmc resource for " .. args.cluster)
      local vmc = getVMC(args.cluster)
      if not(vmc) or not(vmc.status) or not(vmc.status.apiUrl) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Unable to fetch vmc api url for vmc " .. args.cluster)
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end

      -- To access managed cluster api server on self signed certificates, the admin cluster api server needs ca certificates for the managed cluster.
      -- A secret is created in admin cluster during mutli cluster setup that contains the prometheus host and this ca certificate.
      -- Here we read the name of that secret from vmc spec and retrieve the secret from cluster and read the cacrt field.
      -- The value of cacrt field is decoded to get the ca certificate and is appended to file being pointed to by the proxy_ssl_trusted_certificate variable.
      serverUrl = vmc.status.apiUrl .. "/" .. vzApiVersion
      if not(vmc.spec) or not(vmc.spec.prometheusSecret) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Unable to fetch prometheus secret name for vmc to access cart for managed cluster " .. args.cluster)
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end

      local secret = getSecret(vmc.spec.prometheusSecret)
      if not(secret) or not(secret.data) or not(secret.data[args.cluster .. ".yaml"]) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Unable to fetch prometheus secret for vmc to access cart for managed cluster " .. args.cluster)
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end

      local decodedSecretYaml = ngx.decode_base64(secret.data[args.cluster .. ".yaml"])
      if not(decodedSecretYaml) then
        ngx.status = 401
        logJsonMessage(ngx.ERR, "Unable to decode prometheus secret for vmc to access cart for managed cluster " .. args.cluster)
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
      end

      local startIndex, endIndex = string.find(decodedSecretYaml, "cacrt: |")
      if startIndex >= 1 and endIndex > startIndex then
        local sub = string.sub(decodedSecretYaml, endIndex+1)
        local startIndex, _ = string.find(sub, "-----BEGIN CERTIFICATE-----")
        local _, endIndex = string.find(sub, "-----END CERTIFICATE-----")
        if startIndex >= 1 and endIndex > startIndex then
          write_file("/etc/nginx/upstream.pem", string.sub(sub, startIndex, endIndex))
        end
      end

      args.cluster = nil
      ngx.req.set_uri_args(args)
      ngx.var.kubernetes_server_url = serverUrl .. ngx.var.uri
    else
      logJsonMessage(ngx.INFO, "Read service account token and set auth header.")
      local serviceAccountToken = getServiceAccountToken();
      ngx.req.set_header("Authorization", "Bearer " .. serviceAccountToken)
      ngx.var.kubernetes_server_url = serverUrl
    end
  nginx.conf: |
    #user  nobody;
    worker_processes  1;

    #error_log  logs/error.log;
    #error_log  logs/error.log  notice;
    #error_log  logs/error.log  info;

    pid        logs/nginx.pid;
    env KUBERNETES_SERVICE_HOST;
    env KUBERNETES_SERVICE_PORT;
    env VZ_API_HOST;
    env VZ_API_VERSION;


    events {
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;

        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';

        error_log  logs/error.log  info;

        sendfile        on;
        #tcp_nopush     on;

        #keepalive_timeout  0;
        keepalive_timeout  65;

        #gzip  on;
        #
        lua_package_path '/usr/local/share/lua/5.1/?.lua;;';
        lua_package_cpath '/usr/local/lib/lua/5.1/?.so;;';
        resolver _NAMESERVER_;
        # cache for discovery metadata documents
        lua_shared_dict discovery 1m;
        #  cache for JWKs
        lua_shared_dict jwks 1m;

        server {
            listen       8775;
            server_name  apiserver;
            root     /opt/nginx/html;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;
            expires           0;
            add_header        Cache-Control private;

            location / {
              lua_ssl_verify_depth 2;
              lua_ssl_trusted_certificate /etc/nginx/upstream.pem;
              set $kubernetes_server_url "";
              rewrite_by_lua_file /etc/nginx/conf.lua;
              proxy_pass $kubernetes_server_url;
              proxy_ssl_trusted_certificate /etc/nginx/upstream.pem;
              header_filter_by_lua_block {
                local h, _ = ngx.req.get_headers()["origin"]
                if h and h ~= "*" and  h ~= "null" then
                  ngx.header["Access-Control-Allow-Origin"] = h
                end

                ngx.header["Access-Control-Allow-Headers"] = "authorization"
              }
            }

            error_page 404 /404.html;
              location = /40x.html {
            }

            #error_page  404              /404.html;

            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;

            location = /50x.html {
                root   html;
            }

            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ {
            #    proxy_pass   http://127.0.0.1;
            #}

            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
            #location ~ \.php$ {
            #    root           html;
            #    fastcgi_pass   127.0.0.1:9000;
            #    fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    include        fastcgi_params;
            #}

            # deny access to .htaccess files, if Apache's document root
            # concurs with nginx's one
            #
            #location ~ /\.ht {
            #    deny  all;
            #}
        }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    }
  startup.sh: |
    #!/bin/bash
    cd `dirname $0`
    cp `dirname $0`/nginx.conf /etc/nginx/nginx.conf
    cp `dirname $0`/conf.lua /etc/nginx/conf.lua
    nameserver=$(grep -i nameserver /etc/resolv.conf | awk '{split($0,line," "); print line[2]}')
    sed -i -e "s|_NAMESERVER_|${nameserver}|g" /etc/nginx/nginx.conf

    mkdir -p /etc/nginx/logs
    touch /etc/nginx/logs/error.log

    export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
    cat /etc/ssl/certs/ca-bundle.crt > /etc/nginx/upstream.pem
    /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf -t -p /etc/nginx
    /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf -p /etc/nginx

    sh -c "`dirname $0`/reload.sh &"
    tail -f /etc/nginx/logs/error.log
  reload.sh: |
    #!/bin/bash

    adminCABundleMD5=""
    defaultCABundleMD5=""
    maxSizeTrustedCertsFileDefault=$(echo $((10*1024*1024)))
    if [[ ! -z "${MAX_SIZE_TRUSTED_CERTS_FILE}" ]]; then
        maxSizeTrustedCertsFileDefault=${MAX_SIZE_TRUSTED_CERTS_FILE}
    fi

    function reload() {
      nginx -t -p /etc/nginx
      if [ $? -eq 0 ]
      then
        echo "Detected Nginx Configuration Change"
        echo "Executing: nginx -s reload -p /etc/nginx"
        nginx -s reload -p /etc/nginx
      fi
    }

    function default_config() {
      if [[ -s /api-config/default-ca-bundle ]]; then
            md5Hash=$(md5sum "/api-config/default-ca-bundle")
            if [ "$defaultCABundleMD5" != "$md5Hash" ] ; then
                cat /api-config/default-ca-bundle > /etc/nginx/upstream.pem
                defaultCABundleMD5="$md5Hash"
                reload
            fi
        fi
    }

    while true
    do
        trustedCertsFileSize=$(wc -c < /etc/nginx/upstream.pem)
        if [ $trustedCertsFileSize -ge $maxSizeTrustedCertsFileDefault ] ; then
            adminCABundleMD5=""
            defaultCABundleMD5=""
        fi

        default_config

        if [[ -s /api-config/admin-ca-bundle ]]; then
            md5Hash=$(md5sum "/api-config/admin-ca-bundle")
            if [ "$adminCABundleMD5" != "$md5Hash" ] ; then
                cat /api-config/admin-ca-bundle > /etc/nginx/upstream.pem
                adminCABundleMD5="$md5Hash"
                reload
            fi
        else 
           if [ "$adminCABundleMD5" != "" ] ; then
                adminCABundleMD5=""
                defaultCABundleMD5=""
                default_config
            fi 
        fi

        sleep 5
    done
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: {{ .Values.api.name }}
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: {{ .Values.api.name }}
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "true"
      labels:
        app: {{ .Values.api.name }}
    spec:
      volumes:
       - name: api-config
         projected:
           sources:
            - secret:
                items:
                  - key: ca.crt
                    path: default-ca-bundle
                name: system-tls
                optional: true
            - secret:
                name: verrazzano-cluster-registration
                optional: true
                items:
                  - key: ca-bundle
                    path: admin-ca-bundle
                  - key: keycloak-url
                    path: keycloak-url
            - configMap:
                name: api-nginx-conf
                items:
                  - key: startup.sh
                    path: startup.sh
                    mode: 0755
                  - key: nginx.conf
                    path: nginx.conf
                    mode: 0744 
                  - key: conf.lua
                    path: conf.lua
                    mode: 0755
                  - key: reload.sh
                    path: reload.sh
                    mode: 0755
      containers:
      - image: {{ .Values.api.imageName }}:{{ .Values.api.imageVersion }}
        imagePullPolicy: {{ .Values.api.pullPolicy }}
        name: {{ .Values.api.name }}
        command: ["/api-config/startup.sh"]
        env:
        - name: VZ_API_HOST
          value: "verrazzano.{{ .Values.config.envName }}.{{ .Values.config.dnsSuffix }}"
        - name: VZ_API_VERSION
          value: "20210501"
        ports:
            - containerPort: {{ .Values.api.port }}
        volumeMounts:
        - mountPath: /api-config
          name: api-config
      serviceAccount: {{ .Values.api.name }}
---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
spec:
  ports:
  - name: api
    port: {{ .Values.api.port }}
    protocol: TCP
    targetPort: {{ .Values.api.port }}
  selector:
    app: {{ .Values.api.name }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Values.api.name }}
  namespace: {{ .Release.Namespace }}
{{- if .Values.global.imagePullSecrets }}
imagePullSecrets:
{{- range .Values.global.imagePullSecrets }}
- name: {{ . }}
{{- end }}
{{- end }}
