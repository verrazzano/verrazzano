// Copyright (c) 2022, Oracle and/or its affiliates.
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

def GIT_COMMIT_TO_USE
def LAST_CLEAN_PERIODIC_COMMIT

pipeline {
    options {
        skipDefaultCheckout true
        timestamps ()
    }

    agent {
        docker {
            image "${RUNNER_DOCKER_IMAGE}"
            args "${RUNNER_DOCKER_ARGS}"
            registryUrl "${RUNNER_DOCKER_REGISTRY_URL}"
            label 'internal'
        }
    }

    parameters {
        choice (name: 'LRE_CLUSTER',
                description: 'Which LRE cluster to run the test against',
                // 1st choice is the default value
                choices: [ "dev", "prod" ])
    }

    environment {
        OCI_OS_NAMESPACE = credentials('oci-os-namespace')
        OCI_OS_BUCKET="verrazzano-builds"

        CLEAN_BRANCH_NAME = "${env.BRANCH_NAME.replace("/", "%2F")}"
        STABLE_COMMIT_OS_LOCATION = "${CLEAN_BRANCH_NAME}/last-stable-commit.txt"
        CLEAN_PERIODIC_OS_LOCATION = "${CLEAN_BRANCH_NAME}-last-clean-periodic-test/verrazzano_periodic-commit.txt"
        STABLE_COMMIT_LOCATION = "${WORKSPACE}/last-stable-commit.txt"
        CLEAN_PERIODIC_LOCATION = "${WORKSPACE}/last-clean-periodic-commit.txt"

        TEST_ENV = "LRE"
        DOCKER_CREDS = credentials('github-packages-credentials-rw')
        DOCKER_EMAIL = credentials('github-packages-email')
        DOCKER_REPO = 'ghcr.io'
        DOCKER_NAMESPACE = 'verrazzano'
        NETRC_FILE = credentials('netrc')
        OCR_CREDS = credentials('ocr-pull-and-push-account')
        OCR_REPO = 'container-registry.oracle.com'
        IMAGE_PULL_SECRET = 'verrazzano-container-registry'
        GOPATH = '/home/opc/go'
        GO_REPO_PATH = "${GOPATH}/src/github.com/verrazzano"
        LRE_CLUSTER_ENV = "${params.LRE_CLUSTER}"

        KUBECONFIG = "${WORKSPACE}/.kube/config"

        //used to emit metrics
        SEARCH_HTTP_ENDPOINT = credentials('search-gw-url')
        PROMETHEUS_CREDENTIALS = credentials('prometheus-credentials')
        SEARCH_PASSWORD = "${PROMETHEUS_CREDENTIALS_PSW}"
        SEARCH_USERNAME = "${PROMETHEUS_CREDENTIALS_USR}"

	    WEBLOGIC_PSW = credentials('weblogic-example-domain-password') // Needed by ToDoList example test
        DATABASE_PSW = credentials('todo-mysql-password') // Needed by ToDoList example test
    }

    stages {
        stage('Clean workspace and checkout') {
            steps {
                sh """
                    echo "${NODE_LABELS}"
                """

                script {
                    checkout scm
                }
                sh """
                    cp -f "${NETRC_FILE}" $HOME/.netrc
                    chmod 600 $HOME/.netrc
                """

                script {
                    try {
                        sh """
                    echo "${DOCKER_CREDS_PSW}" | docker login ${env.DOCKER_REPO} -u ${DOCKER_CREDS_USR} --password-stdin
                        """
                    } catch(error) {
                        echo "docker login failed, retrying after sleep"
                        retry(4) {
                            sleep(30)
                            sh """
                    echo "${DOCKER_CREDS_PSW}" | docker login ${env.DOCKER_REPO} -u ${DOCKER_CREDS_USR} --password-stdin
                            """
                        }
                    }
                }
                sh """
                    rm -rf ${GO_REPO_PATH}/verrazzano
                    mkdir -p ${GO_REPO_PATH}/verrazzano
                    tar cf - . | (cd ${GO_REPO_PATH}/verrazzano/ ; tar xf -)
                """

                script {
                    def props = readProperties file: '.verrazzano-development-version'
                    VERRAZZANO_DEV_VERSION = props['verrazzano-development-version']
                    TIMESTAMP = sh(returnStdout: true, script: "date +%Y%m%d%H%M%S").trim()
                    SHORT_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse --short=8 HEAD").trim()
                    DOCKER_IMAGE_TAG = "${VERRAZZANO_DEV_VERSION}-${TIMESTAMP}-${SHORT_COMMIT_HASH}"
                }
            }
        }

        stage('Set kubeconfig') {
            steps {
                script {
                    switch(env.LRE_CLUSTER_ENV) {
                        case "dev":
                            env.LRE_KUBECONFIG = "config.dev.lre"
                            break
                        case "prod":
                            // Placeholder for prod - not functioning yet
                            env.LRE_KUBECONFIG = "config.prod.lre"
                            break
                        default:
                            env.LRE_KUBECONFIG = "config.dev.lre"
                            break
                    }
                    sh """
                        echo "${env.LRE_KUBECONFIG}"
                        mkdir -p ${WORKSPACE}/.kube
                        cp ${GO_REPO_PATH}/verrazzano/ci/lre/${env.LRE_KUBECONFIG} ${KUBECONFIG}
                        cat ${KUBECONFIG}
                    """
                }
            }
        }

        stage ("run kubectl commands") {
            steps {
                script {
                    sh '''
                        echo "run kubectl get nodes"
                        kubectl get nodes
                        echo "run kubectl get pods"
                        kubectl get pods -A
                    '''
                }
            }
        }

       stage('Check last clean periodic') {
            steps {
                sh """
                    oci --region us-phoenix-1 os object get --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${STABLE_COMMIT_OS_LOCATION} --file ${STABLE_COMMIT_LOCATION}
                """

                script {

                    // Get the last stable commit ID that passed the triggered tests
                    def stableCommitProps = readProperties file: "${STABLE_COMMIT_LOCATION}"
                    GIT_COMMIT_TO_USE = stableCommitProps['git-commit']
                    echo "Last stable commit: ${GIT_COMMIT_TO_USE}"

                   /*
                    LAST_CLEAN_PERIODIC_COMMIT=getLastCleanPeriodicCommit()
                    echo "Last clean periodics commit: ${LAST_CLEAN_PERIODIC_COMMIT}"

                    if (LAST_CLEAN_PERIODIC_COMMIT == GIT_COMMIT_TO_USE) {
                        periodicsUpToDate = true
                    }

                    echo "Up to date: ${periodicsUpToDate}"
                    echo "Dry run: ${params.DRY_RUN}"
                    echo "Force run: ${params.FORCE}"
                    echo "Execute tests: " + runTests()

                    // Indicate in title if run is up-to-date or dry-run
                    if (params.DRY_RUN) {
                        currentBuild.displayName = "${currentBuild.displayName} : DRY-RUN"
                    }
                    if (periodicsUpToDate) {
                        currentBuild.displayName = "${currentBuild.displayName} : UP-TO-DATE"
                    }
                    if (params.FORCE) {
                        currentBuild.displayName = "${currentBuild.displayName} : FORCE"
                    }

                    if (runTests()) {
                        echo "Executing periodic tests for commit ${GIT_COMMIT_TO_USE}"
                    }
                    */
                }
            }
        }

    }
    post {
        cleanup {
            emitJobMetrics()
        }
    }
}

// Returns the last clean commit for the periodics, or null if the commit file does not exist yet.
// - fails the pipeline if any error other than 404 is returned by the OCI CLI
def getLastCleanPeriodicCommit() {
    lastPeriodicCommitCommandOutput = sh (
        label: "Get last clean periodic commit ID",
        script: "oci --region us-phoenix-1 os object get --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${CLEAN_PERIODIC_OS_LOCATION} --file ${CLEAN_PERIODIC_LOCATION} 2>&1 || true",
        returnStdout: true
        ).trim()
    echo "command out: ${lastPeriodicCommitCommandOutput}"
    if (lastPeriodicCommitCommandOutput.length() > 0) {
        assert lastPeriodicCommitCommandOutput =~ /(.*)status(.*)404(.*)/ : "An unexpected error occurred getting last periodic commit from ObjectStore: ${lastPeriodicCommitCommandOutput}"
    }
    // Get the commit ID for the last known clean pass of the Periodic tests
    def cleanPeriodicsCommitProps = readProperties file: "${CLEAN_PERIODIC_LOCATION}"
    return cleanPeriodicsCommitProps['git-commit']
}

def runGinkgoRandomize(testSuitePath) {
    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
        sh """
            cd ${GO_REPO_PATH}/verrazzano/tests/e2e
            echo in runGinkgoRandomize ${KUBECONFIG}
            cat ${KUBECONFIG}
            ginkgo -p --randomize-all -v --keep-going --no-color ${testSuitePath}/...
        """
    }
}

def runGinkgo(testSuitePath) {
    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
        sh """
            cd ${GO_REPO_PATH}/verrazzano/tests/e2e
            ginkgo -v --keep-going --no-color ${testSuitePath}/...
        """
    }
}

def emitJobMetrics() {
    env.JOB_STATUS = "${currentBuild.currentResult}".trim()
    long duration = "${currentBuild.duration}" as long;
    env.DURATION = duration
    long timeInMillis = "${currentBuild.timeInMillis}" as long;
    long startTimeInMillis = "${currentBuild.startTimeInMillis}" as long;
    env.TIME_WAITING = startTimeInMillis-timeInMillis
    runGinkgoRandomize('jobmetrics')
}
