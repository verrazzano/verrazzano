// Copyright (c) 2021, 2023, Oracle and/or its affiliates.
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

import groovy.transform.Field

@Field
def GIT_COMMIT_TO_USE = ""
@Field
def LAST_CLEAN_PERIODIC_COMMIT = ""
@Field
def LAST_PERIODIC_RUN_COMMIT = ""
@Field
def VERRAZZANO_DEV_VERSION = ""
@Field
def VERSIONED_IMAGES_FILENAME = ""
def agentLabel = env.JOB_NAME.contains('master') ? "phx-small" : "small"
@Field
def TESTS_FAILED = false
@Field
def storeLocation=""
@Field
def verrazzanoPrefix="verrazzano-"
@Field
def fullBundle=""
@Field
def liteBundle=""
@Field
def SUSPECT_LIST = ""
@Field
def COMPARISON_URL_ON_FAILURE = ""

// The job name from which the verrazzano_images file is available to be copied to this job
// We will copy over and make it part of the artifacts of the periodic job, available when we want to release a candidate
@Field
def verrazzanoImagesJobProjectName = "verrazzano-examples"
@Field
def verrazzanoImagesFile           = "verrazzano_images.txt"
@Field
def verrazzanoImagesBuildNumber    = 0     // will be set to actual build number when the job is run
@Field
def periodicsUpToDate              = false // If true, indicates that the periodics already passed at the latest commit
@Field
def periodicsUpToDateFailed        = false // If true, indicates that the periodics already ran and failed at the latest commit

// Non Fields
def branchSpecificSchedule = getCronSchedule()

// File containing the links to download the Verrazzano distributions
@Field
def verrazzanoDistributionsFile = "verrazzano_distributions.html"

def ociOsRegion = "us-phoenix-1"
def ociOsBucket = "verrazzano-builds"
def urlTriggerBranchName = env.BRANCH_NAME.replace('/', '%2F')
def lastStableCommitFile = "last-stable-commit.txt"

pipeline {
    options {
        timeout(time: 12, unit: 'HOURS')
        skipDefaultCheckout true
        disableConcurrentBuilds()
        timestamps ()
    }

    agent {
       docker {
            image "${RUNNER_DOCKER_IMAGE}"
            args "${RUNNER_DOCKER_ARGS}"
            registryUrl "${RUNNER_DOCKER_REGISTRY_URL}"
            registryCredentialsId 'ocir-pull-and-push-account'
            label "${agentLabel}"
        }
    }

    triggers {
        URLTrigger(
            cronTabSpec: branchSpecificSchedule,
            entries: [
                URLTriggerEntry(
                    url: "https://objectstorage.${ociOsRegion}.oraclecloud.com/n/${OS_NAMESPACE_URL_TRIGGER}/b/${ociOsBucket}/o/${urlTriggerBranchName}/${lastStableCommitFile}",
                    checkETag: false,
                    checkStatus: true,
                    statusCode: 403,
                    checkLastModificationDate: true,
                    timeout: 200,
                    requestHeaders: [
                        RequestHeader( headerName: "Accept" , headerValue: "application/json" )
                    ],
                    contentTypes: [
                        MD5Sum()
                    ]
                )
            ]
        )
    }

    parameters {
        string (name: 'TAGGED_TESTS',
                defaultValue: '',
                description: 'A comma separated list of build tags for tests that should be executed (e.g. unstable_test). Default:',
                trim: true)
        string (name: 'INCLUDED_TESTS',
                defaultValue: '.*',
                description: 'A regex matching any fully qualified test file that should be executed (e.g. examples/helidon/). Default: .*',
                trim: true)
        string (name: 'EXCLUDED_TESTS',
                defaultValue: '_excluded_test',
                description: 'A regex matching any fully qualified test file that should not be executed (e.g. multicluster/|_excluded_test). Default: _excluded_test',
                trim: true)
        booleanParam (description: 'Force execution of the tests even if up-to-date', name: 'FORCE', defaultValue: false)
        booleanParam (description: 'Skip test execution (for debugging)', name: 'DRY_RUN', defaultValue: false)
    }

    environment {
        IS_PERIODIC_PIPELINE = "true"
        OCIR_SCAN_COMPARTMENT = credentials('ocir-scan-compartment')
        OCIR_SCAN_TARGET = credentials('ocir-scan-target')
        OCIR_SCAN_REGISTRY = credentials('ocir-scan-registry')
        OCIR_SCAN_REPOSITORY_PATH = credentials('ocir-scan-repository-path')
        DOCKER_SCAN_CREDS = credentials('v8odev-ocir')
        DOCKER_CREDS = credentials('github-packages-credentials-rw')
        DOCKER_REPO = 'ghcr.io'

        OCI_CLI_AUTH="instance_principal"
        OCI_OS_NAMESPACE = credentials('oci-os-namespace')
        OCI_OS_BUCKET="verrazzano-builds"
        OCI_OS_COMMIT_BUCKET="verrazzano-builds-by-commit"
        CLEAN_BRANCH_NAME = "${env.BRANCH_NAME.replace("/", "%2F")}"
        SERVICE_KEY = credentials('PAGERDUTY_SERVICE_KEY')

        STABLE_COMMIT_OS_LOCATION = "${CLEAN_BRANCH_NAME}/last-stable-commit.txt"
        LAST_PERIODIC_OS_LOCATION = "${CLEAN_BRANCH_NAME}/last-periodic-run-commit.txt"
        CLEAN_PERIODIC_OS_LOCATION = "${CLEAN_BRANCH_NAME}-last-clean-periodic-test/verrazzano_periodic-commit.txt"

        STABLE_COMMIT_LOCATION = "${WORKSPACE}/last-stable-commit.txt"
        LAST_PERIODIC_LOCATION = "${WORKSPACE}/last-periodic-run-commit.txt"
        CLEAN_PERIODIC_LOCATION = "${WORKSPACE}/last-clean-periodic-commit.txt"

        OCI_OS_REGION="us-phoenix-1"

        PIPELINE_OWNERS = credentials('periodictests-owners')
    }

    // This job runs against the latest stable master commit. That is defined as the last clean master build and test run whose
    // commit has been stored in object storage. This job will fetch that commit from master and run extended tests using that.
    // This job is NOT currently setup to run extended tests from other branches, if you need to run those extended jobs you will
    // need to run those against your branch individually.

    stages {
        stage('Check last clean periodic') {
            steps {
                sh """
                    oci --region us-phoenix-1 os object get --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${STABLE_COMMIT_OS_LOCATION} --file ${STABLE_COMMIT_LOCATION}
                """

                script {
                    // Check if there is already a clean periodic run at this commit already, and set the display name if
                    // it already is tested, or if doing a special run type (dry run, etc...)
                    preliminaryChecks()
                }
            }
        }
        stage('Clean workspace and checkout') {
            when {
                allOf {
                    expression { return runTests() }
                }
            }
            steps {
                script {
                    cleanWorkspaceAndCheckout()
                }
            }
        }
        stage ('Periodic Test Suites') {
            when {
                allOf {
                    expression { return runTests() }
                }
            }
            parallel {
                stage('OCI DNS tests with instance principal') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-new-oci-dns-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'OCI_DNS_AUTH', value: 'instance_principal'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'VERRAZZANO_OPERATOR_IMAGE', value: params.VERRAZZANO_OPERATOR_IMAGE),
                                        booleanParam(name: 'CREATE_CLUSTER_USE_CALICO', value: true),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                    ], wait: true
                            }
                        }
                    }
               }
                stage('Verrazzano in OCNE environment') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-ocne/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'VERRAZZANO_OPERATOR_IMAGE', value: params.VERRAZZANO_OPERATOR_IMAGE),
                                        booleanParam(name: 'CREATE_CLUSTER_USE_CALICO', value: false),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                    ], wait: true
                            }
                        }
                    }
                }
               stage('Backup and Restore Tests') {
                   steps {
                       retry(count: JOB_PROMOTION_RETRIES) {
                           script {
                               build job: "/verrazzano-backup-all-test-oke/${CLEAN_BRANCH_NAME}",
                                   parameters: [
                                       string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                       string(name: 'VERRAZZANO_OPERATOR_IMAGE', value: 'NONE'),
                                       string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                       string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                       string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                   ], wait: true
                           }
                       }
                   }
               }
                stage('Kind Acceptance Tests With HA and Grafana DB on 1.26') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-new-kind-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                        booleanParam(name: 'ENABLE_JWT_TESTING', value: true),
                                        booleanParam(name: 'INSTALL_HA', value: true),
                                        booleanParam(name: 'USE_DB_FOR_GRAFANA', value: true)
                        ], wait: true
                            }
                        }
                    }
                }
                stage('Kind Acceptance Tests on 1.24') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-new-kind-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                        parameters: [
                                                string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.24'),
                                                string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                                string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                                string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                                string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                                booleanParam(name: 'ENABLE_JWT_TESTING', value: true)
                                        ], wait: true
                            }
                        }
                    }
                }
                stage('Kind Acceptance Tests on 1.25') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-new-kind-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                        parameters: [
                                                string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.25'),
                                                string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                                string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                                string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                                string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                                booleanParam(name: 'ENABLE_JWT_TESTING', value: true)
                                        ], wait: true
                            }
                        }
                    }
                }
                stage('Verrazzano a-la-carte') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-a-la-carte/${CLEAN_BRANCH_NAME}",
                                        parameters: [
                                                string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                                string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        ], wait: true
                            }
                        }
                    }
                }
                stage('HA tests') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-ha-tests/${CLEAN_BRANCH_NAME}",
                                        parameters: [
                                                string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                                string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                                string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                                string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                        ], wait: true
                            }
                        }
                    }
                }
                stage('Upgrade Resiliency tests') {
                    steps {
                        script {
                            build job: "/verrazzano-upgrade-resiliency-tests/${CLEAN_BRANCH_NAME}",
                                parameters: [
                                    string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                    string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                    string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                    string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                ], wait: true
                        }
                    }
                }
                stage('Uninstall Resiliency tests') {
                    steps {
                        script {
                            build job: "/verrazzano-uninstall-resiliency-suite/${CLEAN_BRANCH_NAME}",
                                parameters: [
                                    string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                    string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                    string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                    string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                ], wait: true
                        }
                    }
                }
                stage('Kind Acceptance Tests on 1.26 Non-Calico') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                // Do not use Calico
                                build job: "verrazzano-new-kind-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        booleanParam(name: 'CREATE_CLUSTER_USE_CALICO', value: false),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                            }
                        }
                    }
                    post {
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('Kind Acceptance Tests on 1.26 sslip.io') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                // test with sslip.io
                                build job: "verrazzano-new-kind-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'WILDCARD_DNS_DOMAIN', value: 'sslip.io'),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                            }
                        }
                    }
                    post {
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('Dynamic Configuration Tests') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "verrazzano-dynamic-config-suite/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                            }
                        }
                    }
                    post {
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('OCI DNS/ACME-Staging Tests') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "verrazzano-new-oci-dns-acceptance-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'CERT_ISSUER', value: "acme"),
                                        string(name: 'ACME_ENVIRONMENT', value: "staging"),
                                        booleanParam(name: 'CREATE_CLUSTER_USE_CALICO', value: false),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                            }
                        }
                    }
                    post {
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('OCI Service Integration Tests') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                build job: "/verrazzano-oci-integration-tests/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                            }
                        }
                    }
                    post {
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('Verrazzano Examples') {
                    steps {
                        retry(count: JOB_PROMOTION_RETRIES) {
                            script {
                                def builtExamples = build job: "/verrazzano-examples/${CLEAN_BRANCH_NAME}",
                                    parameters: [
                                        string(name: 'KUBERNETES_CLUSTER_VERSION', value: '1.26'),
                                        string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                        string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                        string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                        string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS)
                                    ], wait: true
                                // The verrazzano-examples job is the one from which we get the verrazzano images file
                                verrazzanoImagesBuildNumber = builtExamples.number
                            }
                        }
                    }
                    post {
                        success {
                            script {
                                if (verrazzanoImagesBuildNumber > 0) {
                                    copyArtifacts(projectName: "${verrazzanoImagesJobProjectName}/${CLEAN_BRANCH_NAME}",
                                        selector: specific("${verrazzanoImagesBuildNumber}"),
                                        filter: verrazzanoImagesFile)
                                    sh """
                                        # Save the images.txt intp the commit specific location, if we have a clean periodic it will copy the images from here to the branch as the current ones
                                        OCI_CLI_AUTH="instance_principal" oci --region us-phoenix-1 os object put --force --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_COMMIT_BUCKET} --name ephemeral/${env.BRANCH_NAME}/${SHORT_COMMIT_HASH}/${VERSIONED_IMAGES_FILENAME} --file ${verrazzanoImagesFile}
                                    """
                                } else {
                                    println("Cannot copy ${verrazzanoImagesFile} from the project ${verrazzanoImagesJobProjectName} - no build number is available to copy from.")
                                }
                            }
                        }
                        failure {
                            script {
                                TESTS_FAILED = true
                            }
                        }
                    }
                }
                stage('Verrazzano Distribution and Private Registry') {
                    steps {
                        script {
                            build job: "/verrazzano-distributions-testing/${CLEAN_BRANCH_NAME}",
                                parameters: [
                                    string(name: 'GIT_COMMIT_TO_USE', value: env.GIT_COMMIT),
                                    string(name: 'TAGGED_TESTS', value: params.TAGGED_TESTS),
                                    string(name: 'INCLUDED_TESTS', value: params.INCLUDED_TESTS),
                                    string(name: 'EXCLUDED_TESTS', value: params.EXCLUDED_TESTS),
                                    string(name: 'RUN_TESTS', value: env.IS_PERIODIC_PIPELINE),
                                ], wait: true
                        }
                    }
                }
            }
        }
        stage('Release Candidate Validation Checks') {
            when {
                allOf {
                    expression { return runTests() }
                }
            }
            steps {
                script {
                    releaseValidationChecks()
                }
            }
        }
        stage('Update Last Clean Periodic Test') {
            environment {
                GIT_COMMIT_USED = "${env.GIT_COMMIT}"
            }
            when {
                allOf {
                    expression { return runTests() }
                }
            }
            steps {
                script {
                    sh """
                        ci/scripts/update_last_clean_periodic_test.sh ${VERRAZZANO_DEV_VERSION} ${SHORT_COMMIT_HASH}
                    """
                }
            }
            post {
                success {
                    script {
                        captureDistributionURLs()
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                // We don't update any object storage artifacts if this run didn't re-run anything (ie: if it was "UpToDate")
                if (!periodicsUpToDate && !periodicsUpToDateFailed) {
                    sh """
                        # Update the last periodic commit
                        echo "git-commit=${env.GIT_COMMIT}" > commit-used.txt
                        cat commit-used.txt
                        oci --region ${OCI_OS_REGION} os object put --force --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${LAST_PERIODIC_OS_LOCATION} --file commit-used.txt
                    """
                } else {
                    println("Skipping update of the last periodic commit used. This run was marked UP-TO-DATE so it is already there")
                }
            }
            archiveArtifacts artifacts: "**/prerelease_validation.out,**/release_status.out,**/${verrazzanoImagesFile},**/${verrazzanoDistributionsFile}", allowEmptyArchive: true
        }
        failure {
            script {
                if (isAlertingEnabled()) {
                    if (isPagerDutyEnabled()) {
                        pagerduty(resolve: false, serviceKey: "$SERVICE_KEY",
                        incDescription: "Verrazzano Periodic Tests: ${env.JOB_NAME} - Failed",
                        incDetails: "Job Failed - \"${env.JOB_NAME}\" build: ${env.BUILD_NUMBER}\n\nView the log at:\n ${env.BUILD_URL}\n\nBlue Ocean:\n${env.RUN_DISPLAY_URL}")
                    }
                    slackSend ( channel: "$SLACK_ALERT_CHANNEL", message: "Job Failed - \"${env.JOB_NAME}\" build: ${env.BUILD_NUMBER}\n\nView the log at:\n ${env.BUILD_URL}\n\nBlue Ocean:\n${env.RUN_DISPLAY_URL}\n\nSuspects:\n${SUSPECT_LIST} ${PIPELINE_OWNERS}\n\nChange comparison: ${COMPARISON_URL_ON_FAILURE}" )
                    echo "done alerts"
                }
            }
        }
        cleanup {
            deleteDir()
        }
    }
}

// Preliminary job checks and display updates
def preliminaryChecks() {
    // Get the last stable commit ID to pass the triggered tests
    def stableCommitProps = readProperties file: "${STABLE_COMMIT_LOCATION}"
    GIT_COMMIT_TO_USE = stableCommitProps['git-commit']
    echo "Last stable commit: ${GIT_COMMIT_TO_USE}"

    LAST_CLEAN_PERIODIC_COMMIT=getLastCleanPeriodicCommit()
    echo "Last clean periodics commit: ${LAST_CLEAN_PERIODIC_COMMIT}"

    if (LAST_CLEAN_PERIODIC_COMMIT == GIT_COMMIT_TO_USE) {
        // If we had a clean periodic run and the commit hasn't changed
        periodicsUpToDate = true
    } else {
        // Check if we are still at the same commit previously run (if so we know it wasn't clean and it failed in some way)
        LAST_PERIODIC_RUN_COMMIT=getLastPeriodicRunCommit()
        if (LAST_PERIODIC_RUN_COMMIT != null && LAST_PERIODIC_RUN_COMMIT == GIT_COMMIT_TO_USE) {
            periodicsUpToDateFailed = true
        }
    }

    echo "Up to date: ${periodicsUpToDate}"
    echo "Dry run: ${params.DRY_RUN}"
    echo "Force run: ${params.FORCE}"
    echo "Execute tests: " + runTests()

    // Indicate in title if run is up-to-date or dry-run
    if (params.DRY_RUN) {
        currentBuild.displayName = "${currentBuild.displayName} : DRY-RUN"
    }
    if (periodicsUpToDate) {
        currentBuild.displayName = "${currentBuild.displayName} : UP-TO-DATE"
    }

    if (params.FORCE) {
        currentBuild.displayName = "${currentBuild.displayName} : FORCE"
    } else if (periodicsUpToDateFailed) {
       currentBuild.displayName = "${currentBuild.displayName} : UP-TO-DATE-FAILED"
       currentBuild.result = 'FAILURE'
       error('Failing the build since the current commit matches the commit of previously failing periodic build')
    }

    if (runTests()) {
        echo "Executing periodic tests for commit ${GIT_COMMIT_TO_USE}"
    }
}

def dockerLogins() {
    try {
        sh """
            echo "${DOCKER_SCAN_CREDS_PSW}" | docker login ${env.OCIR_SCAN_REGISTRY} -u ${DOCKER_SCAN_CREDS_USR} --password-stdin
        """
    } catch(error) {
        echo "docker login failed, retrying after sleep"
        retry(4) {
            sleep(30)
            sh """
            echo "${DOCKER_SCAN_CREDS_PSW}" | docker login ${env.OCIR_SCAN_REGISTRY} -u ${DOCKER_SCAN_CREDS_USR} --password-stdin
            """
        }
    }
    if (!(env.BRANCH_NAME.equals("master") || env.BRANCH_NAME.startsWith("release-1."))) {
        try {
            sh """
                echo "${DOCKER_CREDS_PSW}" | docker login ${env.DOCKER_REPO} -u ${DOCKER_CREDS_USR} --password-stdin
            """
        } catch(error) {
            echo "docker login failed, retrying after sleep"
            retry(4) {
                sleep(30)
                sh """
                    echo "${DOCKER_CREDS_PSW}" | docker login ${env.DOCKER_REPO} -u ${DOCKER_CREDS_USR} --password-stdin
                """
            }
        }
    }
}

def scmCheckout() {
    echo "${NODE_LABELS}"
    echo "SCM checkout of ${GIT_COMMIT_TO_USE}"
    def scmInfo = checkout([
        $class: 'GitSCM',
        branches: [[name: GIT_COMMIT_TO_USE]],
        doGenerateSubmoduleConfigurations: false,
        extensions: [],
        submoduleCfg: [],
        userRemoteConfigs: [[url: env.SCM_VERRAZZANO_GIT_URL]]])
    env.GIT_COMMIT = scmInfo.GIT_COMMIT
    env.GIT_BRANCH = scmInfo.GIT_BRANCH
    echo "SCM checkout of ${env.GIT_BRANCH} at ${env.GIT_COMMIT}"
    // If the commit we were handed is not what the SCM says we are using, fail
    if (!env.GIT_COMMIT.equals(GIT_COMMIT_TO_USE)) {
        error( "SCM didn't checkout the commit we expected. Expected: ${GIT_COMMIT_TO_USE}, Found: ${scmInfo.GIT_COMMIT}")
    }

    if (LAST_CLEAN_PERIODIC_COMMIT != null) {
        COMPARISON_URL_ON_FAILURE = "https://github.com/verrazzano/verrazzano/compare/${LAST_CLEAN_PERIODIC_COMMIT}...${GIT_COMMIT_TO_USE}"
        def lastClean = "${LAST_CLEAN_PERIODIC_COMMIT}"
        def currentStable = "${GIT_COMMIT_TO_USE}"
        def commitList = getCommitListFromGitLog(lastClean, currentStable)
        withCredentials([file(credentialsId: 'jenkins-to-slack-users', variable: 'JENKINS_TO_SLACK_JSON')]) {
            def userMappings = readJSON file: JENKINS_TO_SLACK_JSON
            SUSPECT_LIST = getSuspectList(commitList, userMappings)
            echo "Suspect list: ${SUSPECT_LIST}"
        }
    }
    echo "URL if fails: ${COMPARISON_URL_ON_FAILURE}"
}

def cleanWorkspaceAndCheckout() {
    scmCheckout()
    dockerLogins()
    def props = readProperties file: '.verrazzano-development-version'
    VERRAZZANO_DEV_VERSION = props['verrazzano-development-version']
    TIMESTAMP = sh(returnStdout: true, script: "date +%Y%m%d%H%M%S").trim()
    SHORT_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse --short=8 HEAD").trim()
    // update the description with some meaningful info
    currentBuild.description = SHORT_COMMIT_HASH + " : " + env.GIT_COMMIT + " : " + GIT_COMMIT_TO_USE
    storeLocation="ephemeral/${env.BRANCH_NAME}/${SHORT_COMMIT_HASH}"
    fullBundle="${storeLocation}/${verrazzanoPrefix}${VERRAZZANO_DEV_VERSION}.zip"
    liteBundle="${storeLocation}/${verrazzanoPrefix}${VERRAZZANO_DEV_VERSION}-lite.zip"
    VERSIONED_IMAGES_FILENAME = "verrazzano_${VERRAZZANO_DEV_VERSION}-images.txt"
}

// Returns the last clean commit for the periodics, or null if the commit file does not exist yet.
// - fails the pipeline if any error other than 404 is returned by the OCI CLI
def getLastCleanPeriodicCommit() {
    lastPeriodicCommitCommandOutput = sh (
        label: "Get last clean periodic commit ID",
        script: "oci --region us-phoenix-1 os object get --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${CLEAN_PERIODIC_OS_LOCATION} --file ${CLEAN_PERIODIC_LOCATION} 2>&1 || true",
        returnStdout: true
        ).trim()
    echo "command out: ${lastPeriodicCommitCommandOutput}"
    if (lastPeriodicCommitCommandOutput.length() > 0) {
        // We can get warning messages here as well even when the command succeeded, so be more precise on the checking
        if (lastPeriodicCommitCommandOutput =~ /(.*)status(.*)\d{1,4}(.*)/) {
            // If we think we had a status: NNN, we ignore 404 and fail for others
            assert lastPeriodicCommitCommandOutput =~ /(.*)status(.*)404(.*)/ : "An unexpected error occurred getting last periodic commit from ObjectStore: ${lastPeriodicCommitCommandOutput}"
        } else {
            // If we got here, we have some message that may or may not be an error. If we don't see the file, we assume it was an error
            sh """
                if [ ! -f ${CLEAN_PERIODIC_LOCATION} ]; then
                    echo "An unexpected error occurred getting last clean periodic commit from ObjectStore: ${lastPeriodicCommitCommandOutput}"
                    exit 1
                fi
            """
        }
    }
    // Get the commit ID for the last known clean pass of the Periodic tests
    def cleanPeriodicsCommitProps = readProperties file: "${CLEAN_PERIODIC_LOCATION}"
    return cleanPeriodicsCommitProps['git-commit']
}

// Returns the last run commit for the periodics, or null if the commit file does not exist yet.
// - fails the pipeline if any error other than 404 is returned by the OCI CLI
def getLastPeriodicRunCommit() {
    lastPeriodicCommitCommandOutput = sh (
        label: "Get last clean periodic commit ID",
        script: "oci --region us-phoenix-1 os object get --namespace ${OCI_OS_NAMESPACE} -bn ${OCI_OS_BUCKET} --name ${LAST_PERIODIC_OS_LOCATION} --file ${LAST_PERIODIC_LOCATION} 2>&1 || true",
        returnStdout: true
        ).trim()
    echo "command out: ${lastPeriodicCommitCommandOutput}"
    if (lastPeriodicCommitCommandOutput.length() > 0) {
        // We can get warning messages here as well even when the command succeeded, so be more precise on the checking
        if (lastPeriodicCommitCommandOutput =~ /(.*)status(.*)\d{1,4}(.*)/) {
            // If we think we had a status: NNN, we ignore 404 and fail for others
            assert lastPeriodicCommitCommandOutput =~ /(.*)status(.*)404(.*)/ : "An unexpected error occurred getting last periodic commit from ObjectStore: ${lastPeriodicCommitCommandOutput}"
        } else {
            // If we got here, we have some message that may or may not be an error. If we don't see the file, we assume it was an error
            sh """
                if [ ! -f ${LAST_PERIODIC_LOCATION} ]; then
                    echo "An unexpected error occurred getting last periodic run commit from ObjectStore: ${lastPeriodicCommitCommandOutput}"
                    exit 1
                fi
            """
        }
    }
    // Get the commit ID for the last known clean pass of the Periodic tests
    def lastPeriodicsCommitProps = readProperties file: "${LAST_PERIODIC_LOCATION}"
    return lastPeriodicsCommitProps['git-commit']
}

// Checks all the conditions gating test execution and coallates the result
def runTests() {
  return params.FORCE || ( ! periodicsUpToDate && ! periodicsUpToDateFailed && ! params.DRY_RUN )
}

def isAlertingEnabled() {
    // this controls whether any alerting happens for these tests
    if (NOTIFY_PERIODIC_FAILURES.equals("true") && (env.BRANCH_NAME.equals("master") || env.BRANCH_NAME.startsWith("release-1."))) {
        echo "Alert notifications enabled for ${env.BRANCH_NAME}"
        return true
    }
    return false
}

def releaseValidationChecks() {
    def built = build job: "verrazzano-prerelease-check/${CLEAN_BRANCH_NAME}",
        parameters: [
            string(name: 'COMMIT_TO_USE', value: env.GIT_COMMIT)
        ], wait: true, propagate: false
    println("Result of verrazzano-prerelease-check is ${built.result}")
    dir ("${WORKSPACE}") {
        copyArtifacts(projectName: "verrazzano-prerelease-check/${CLEAN_BRANCH_NAME}",
                selector: specific("${built.number}"));
        def releaseStatus = readFile file: "release_status.out"
        currentBuild.displayName = "${currentBuild.displayName} : ${releaseStatus}"
    }
}

def isPagerDutyEnabled() {
    // this additionally controls whether PD alerts are enabled (note that you must also enable alerting in general as well if you want these)
    if (NOTIFY_PAGERDUTY_PERIODIC_FAILURES.equals("true")) {
        echo "Pager-Duty notifications enabled via global override setting"
        return true
    }
    return false
}

def getCronSchedule() {
    if (env.BRANCH_NAME.equals("master")) {
        return "H */6 * * *"
    } else if (env.BRANCH_NAME.startsWith("release-1")) {
        return "@daily"
    }
    return ""
}

// Called in Stage Clean workspace and checkout steps
def getCommitListFromGitLog(lastClean, currentStable) {
    echo "Checking for change sets"
    def commitList = sh(returnStdout: true, script: "git log ${lastClean}...${currentStable} --oneline | cut -d \" \" -f 1").trim().split('\n')
    for (int i = 0; i < commitList.size(); i++) {
        echo "Found commit id: ${commitList[i]}"
    }
    return commitList
}

def trimIfGithubNoreplyUser(userIn) {
    if (userIn == null) {
        echo "Not a github noreply user, not trimming: ${userIn}"
        return userIn
    }
    if (userIn.matches(".*\\+.*@users.noreply.github.com.*")) {
        def userOut = userIn.substring(userIn.indexOf("+") + 1, userIn.indexOf("@"))
        return userOut;
    }
    if (userIn.matches(".*<.*@users.noreply.github.com.*")) {
        def userOut = userIn.substring(userIn.indexOf("<") + 1, userIn.indexOf("@"))
        return userOut;
    }
    if (userIn.matches(".*@users.noreply.github.com")) {
        def userOut = userIn.substring(0, userIn.indexOf("@"))
        return userOut;
    }
    echo "Not a github noreply user, not trimming: ${userIn}"
    return userIn
}

def getSuspectList(commitList, userMappings) {
    def retValue = ""
    def suspectList = []
    if (commitList == null || commitList.size() == 0) {
        echo "No commits to form suspect list"
    } else {
        for (int i = 0; i < commitList.size(); i++) {
            def id = commitList[i]
            try {
                def gitAuthor = sh(
                    script: "git log --format='%ae' '$id^!'",
                    returnStdout: true
                ).trim()
                if (gitAuthor != null) {
                    def author = trimIfGithubNoreplyUser(gitAuthor)
                    echo "DEBUG: author: ${gitAuthor}, ${author}, id: ${id}"
                    if (userMappings.containsKey(author)) {
                        def slackUser = userMappings.get(author)
                        if (!suspectList.contains(slackUser)) {
                            echo "Added ${slackUser} as suspect"
                            retValue += " ${slackUser}"
                            suspectList.add(slackUser)
                        }
                    } else {
                        // If we don't have a name mapping use the commit.author, at least we can easily tell if the mapping gets dated
                        if (!suspectList.contains(author)) {
                            echo "Added ${author} as suspect"
                            retValue += " ${author}"
                            suspectList.add(author)
                        }
                    }
                } else {
                    echo "No author returned from git"
                }
            } catch (Exception e) {
                echo "INFO: Problem processing commit ${id}, skipping commit: " + e.toString()
            }
        }
    }
    def startedByUser = "";
    def causes = currentBuild.getBuildCauses()
    echo "causes: " + causes.toString()
    for (cause in causes) {
        def causeString = cause.toString()
        echo "current cause: " + causeString
        def causeInfo = readJSON text: causeString
        if (causeInfo.userId != null) {
            startedByUser = causeInfo.userId
        }
    }

    if (startedByUser.length() > 0) {
        echo "Build was started by a user, adding them to the suspect notification list: ${startedByUser}"
        def author = trimIfGithubNoreplyUser(startedByUser)
        echo "DEBUG: author: ${startedByUser}, ${author}"
        if (userMappings.containsKey(author)) {
            def slackUser = userMappings.get(author)
            if (!suspectList.contains(slackUser)) {
                echo "Added ${slackUser} as suspect"
                retValue += " ${slackUser}"
                suspectList.add(slackUser)
            }
        } else {
            // If we don't have a name mapping use the commit.author, at least we can easily tell if the mapping gets dated
            if (!suspectList.contains(author)) {
               echo "Added ${author} as suspect"
               retValue += " ${author}"
               suspectList.add(author)
            }
        }
    } else {
        echo "Build not started by a user, not adding to notification list"
    }
    echo "returning suspect list: ${retValue}"
    return retValue
}

@NonCPS
List extractReleaseTags(final String fileContent) {
    List releases = []
    fileContent.eachLine { tag ->
        releases << tag
    }
    return releases
}

def getLatestReleaseVersion() {
    final String releaseTags = readFile(file: "${workspace}/tags.txt")
    list gitTags = extractReleaseTags(releaseTags)
    echo "gitTags = ${gitTags}"
    return gitTags.pop()
}

// Create a html file containing the links to the Verrazzano distributions
def captureDistributionURLs() {
    script {
        def BRANCH_IN_OS = "${env.BRANCH_NAME.replace("/", "%252F")}"
        BASE_URL="https://objectstorage.${OCI_OS_REGION}.oraclecloud.com/n/${OCI_OS_NAMESPACE}/b/${OCI_OS_BUCKET}/o/${BRANCH_IN_OS}-last-clean-periodic-test"
        LITE_BUNDLE="${BASE_URL}/${verrazzanoPrefix}${VERRAZZANO_DEV_VERSION}-lite.zip"
        FULL_BUNDLE="${BASE_URL}/${verrazzanoPrefix}${VERRAZZANO_DEV_VERSION}.zip"
        sh """
            cat <<EOF > ${WORKSPACE}/${verrazzanoDistributionsFile}
<!DOCTYPE html>
<html>
      <body>
          <b>Verrazzano Release Distributions</b>
		  <ul>
		    <li><a href="${LITE_BUNDLE}">Verrazzano Lite Distribution</a></li>
		    <li><a href="${FULL_BUNDLE}">Verrazzano Full Distribution</a></li>
		  </ul>
      </body>
</html>
EOF
        """
    }
}
