// Copyright (c) 2023, Oracle and/or its affiliates.
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

import groovy.transform.Field

@Field
def LAST_RUN_COMMIT = ""
@Field
def GIT_COMMIT_TO_USE = ""
@Field
def LAST_CLEAN_BACKEND_COMMIT = ""
def agentLabel = env.JOB_NAME.contains('master') ? "phx-small" : "small"
@Field
def TESTS_FAILED = false
@Field
def storeLocation=""
@Field
def verrazzanoPrefix="verrazzano-"
@Field
def fullBundle=""
@Field
def liteBundle=""
@Field
def SUSPECT_LIST = ""
@Field
def COMPARISON_URL_ON_FAILURE = ""

// Non Fields
def branchSpecificSchedule = getCronSchedule()

// File containing the links to download the Verrazzano distributions
@Field
def verrazzanoDistributionsFile = "verrazzano_distributions.html"

def ociOsRegion = "us-phoenix-1"
def ociOsBucket = "verrazzano-builds"
def urlTriggerBranchName = env.BRANCH_NAME.replace('/', '%2F')
def lastStableCommitFile = "last-stable-commit.txt"

pipeline {
    options {
        timeout(time: 12, unit: 'HOURS')
        skipDefaultCheckout true
        disableConcurrentBuilds()
        timestamps ()
    }

    agent {
       docker {
            image "${RUNNER_DOCKER_IMAGE}"
            args "${RUNNER_DOCKER_ARGS}"
            registryUrl "${RUNNER_DOCKER_REGISTRY_URL}"
            registryCredentialsId 'ocir-pull-and-push-account'
            label "${agentLabel}"
        }
    }

    triggers {
        cron(branchSpecificSchedule)
    }

    stages {
        stage('Get last commit ran') {
            steps {
                script {
                    try {
                        LAST_RUN_COMMIT = params.LAST_RUN_COMMIT
                    }
                    catch (Exception e) {
                        echo("Could not read variable from parameters, assuming this is the first run of the pipeline. Exception: ${e}")
                        LAST_RUN_COMMIT = ""
                    }
                }
            }
        }

        stage ('Run Periodic Test Suite') {
                    when {
                        allOf {
                            expression { return runPipeline() }
                        }
                    }

                    steps {
                        script {
                            build job: "/verrazzano-periodic-triggered-tests/${CLEAN_BRANCH_NAME}", wait: true
                        }
                    }
                }

        stage('Store last commit ran') {
            steps {
                script {
                    properties: [
                        parameters: [
                            string(defaultValue: "${LAST_RUN_COMMIT}", description: 'Variable description', name: 'LAST_RUN_COMMIT', trim: true)
                        ]
                    ]
                }
            }
        }
    }
}

def scmCheckout() {
    echo "${NODE_LABELS}"
    echo "SCM checkout of ${GIT_COMMIT_TO_USE}"
    def scmInfo = checkout([
        $class: 'GitSCM',
        branches: [[name: GIT_COMMIT_TO_USE]],
        doGenerateSubmoduleConfigurations: false,
        extensions: [],
        submoduleCfg: [],
        userRemoteConfigs: [[url: env.SCM_VERRAZZANO_GIT_URL]]])
    env.GIT_COMMIT = scmInfo.GIT_COMMIT
    env.GIT_BRANCH = scmInfo.GIT_BRANCH
    echo "SCM checkout of ${env.GIT_BRANCH} at ${env.GIT_COMMIT}"
    // If the commit we were handed is not what the SCM says we are using, fail
    if (!env.GIT_COMMIT.equals(GIT_COMMIT_TO_USE)) {
        error( "SCM didn't checkout the commit we expected. Expected: ${GIT_COMMIT_TO_USE}, Found: ${scmInfo.GIT_COMMIT}")
    }

    if (LAST_CLEAN_BACKEND_COMMIT != null) {
        COMPARISON_URL_ON_FAILURE = "https://github.com/verrazzano/verrazzano/compare/${LAST_CLEAN_BACKEND_COMMIT}...${GIT_COMMIT_TO_USE}"
        def lastClean = "${LAST_CLEAN_BACKEND_COMMIT}"
        def currentStable = "${GIT_COMMIT_TO_USE}"
        def commitList = getCommitListFromGitLog(lastClean, currentStable)
        withCredentials([file(credentialsId: 'jenkins-to-slack-users', variable: 'JENKINS_TO_SLACK_JSON')]) {
            def userMappings = readJSON file: JENKINS_TO_SLACK_JSON
            SUSPECT_LIST = getSuspectList(commitList, userMappings)
            echo "Suspect list: ${SUSPECT_LIST}"
        }
    }
    echo "URL if fails: ${COMPARISON_URL_ON_FAILURE}"
}

def cleanWorkspaceAndCheckout() {
    scmCheckout()
    dockerLogins()
    TIMESTAMP = sh(returnStdout: true, script: "date +%Y%m%d%H%M%S").trim()
    SHORT_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse --short=8 HEAD").trim()
    // update the description with some meaningful info
    currentBuild.description = SHORT_COMMIT_HASH + " : " + env.GIT_COMMIT + " : " + GIT_COMMIT_TO_USE
    storeLocation="ephemeral/${env.BRANCH_NAME}/${SHORT_COMMIT_HASH}"
}

def getCronSchedule() {
    if (env.BRANCH_NAME.equals("master")) {
        // scheduled for every 6 hours
        return "0 */6 * * *"
    } else if (env.BRANCH_NAME.startsWith("release-")) {
        return "0 */6 * * *"
    }
    return ""
}

// Checks all the conditions gating test execution and collates the result
def runPipeline() {
  return LAST_RUN_COMMIT != env.GIT_COMMIT
}

For each branch (master + release-*) {
    Check if there is anything in objectstore for each branch {
        If yes, check state {
            If state changed, kick off new jobs {
                commit = get(https://objectstorage.us-phoenix-1.oraclecloud.com/n/stevengreenberginc/b/verrazzano-builds/o/master/last-stable-commit.txt)
                if state.lastBackend != commit {
                    (run backend pipeline with new commit)
                    state.lastBackend = commit
                }
            }
            If no change, ignore/continue
        }
        If no, kick off new jobs (first time seeing new url/pipeline) {
            (run periodics pipeline with new commit)
            state.lastPeriodics = commit
            (run backend pipeline with new commit)
            state.lastPeriodics = commit
        }
    }
}